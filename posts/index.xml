<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on cakephp-with-me</title>
    <link>https://cake.nichiyoubi.land/posts/</link>
    <description>Recent content in Posts on cakephp-with-me</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 25 Dec 2018 00:00:06 +0900</lastBuildDate>
    
	<atom:link href="https://cake.nichiyoubi.land/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Resource Routing</title>
      <link>https://cake.nichiyoubi.land/posts/36-resource-routing/</link>
      <pubDate>Tue, 25 Dec 2018 00:00:06 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/36-resource-routing/</guid>
      <description>※1人AdventのDay-24です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
概要 CakePHPのRouterには、ある名前のリソースに対してRESTfulなアクセスを簡単に提供する機能 resources() があります。
その内部実装がどのようになっているのか、処理を追ってみました。
イントロ CakePHPは伝統的に設定より規約を重んじるフレームワークであり、Routingにもその色が濃く出ています。
CakePHP2の時代と違い、交換・取り外し可能にはなりましたが、fallbackを用いて「コントローラー/アクション」を自動的にマッピングし、起動する機構は健在です。
そうして、CakePHPにおいてはRoutingとは「書かなくても動くもの」としての性質がありますが、その方向性を更に強化するのがResource Routingだと感じます。
Resource Routingは、対象の「リソース」の名前を指定することで、RESTfulなエンドポイントを仕立てる機能です。
Bookにある例を引用し、概要の紹介とします。
ルーティング - 3.7
// config/routes.php 内で... Router::scope(&#39;/&#39;, function ($routes) { // 3.5.0 より前は `extensions()` を使用 $routes-&amp;gt;setExtensions([&#39;json&#39;]); $routes-&amp;gt;resources(&#39;Recipes&#39;); });     HTTP format URL.format 対応するコントローラーアクション     GET /recipes.format RecipesController::index()   GET /recipes/123.format RecipesController::view(123)   POST /recipes.format RecipesController::add()   PUT /recipes/123.format RecipesController::edit(123)   PATCH /recipes/123.</description>
    </item>
    
    <item>
      <title>ObjectRegistryについて</title>
      <link>https://cake.nichiyoubi.land/posts/35-object-registry/</link>
      <pubDate>Sun, 23 Dec 2018 07:35:23 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/35-object-registry/</guid>
      <description>※1人AdventのDay-23です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
概要 ObjectRegistryというものがあります。
CakePHPで内部的にかなり頻繁に利用されているクラスであり、インスタンス管理の根幹を担っていると言っても過言ではありません。
どんな使われ方をされていて、どんな処理をしているのかを見てみました。
イントロ CakePHPを用いたアプリケーションを作成していくに当たり、自身で直接触れることはあまりなさそうなクラスです。 class docを見ると、以下のように書かれています。
Acts as a registry/factory for objects. Provides registry &amp;amp; factory functionality for object types. Used as a super class for various composition based re-use features in CakePHP. Each subclass needs to implement the various abstract methods to complete the template method load().  1つとして「普段は抽象的に操作をしている部分を少し具体的に知ることができたら、より納得感をもって開発ができるだろう」という視点、2つ目に「自身が実装や設計を考えるにあたって学びがありそうだ」という視点で内部構造を見てみたいと思いました。
ObjectRegistryはどこで利用されているか ObjectRegistryは抽象クラスであり、Countable/IteratorAggregateといったインターフェイスを実装します。ここから分かる通り、「コレクション」としての性格を備えたものです。
この利用先は、どのようなクラスがあるでしょうか。
一覧を列挙してみます。
 \Cake\Cache\CacheRegistry \Cake\Console\HelperRegistry \Cake\Console\TaskRegistry \Cake\Controller\ComponentRegistry \Cake\Datasource\ConnectionRegistry \Cake\Log\LogEngineRegistry \Cake\Mailer\TransportRegistry \Cake\ORM\BehaviorRegistry \Cake\View\HelperRegistry  このように、「〜Registry」というsuffixをつける、という規則が見いだせます。</description>
    </item>
    
    <item>
      <title>fixturize: テストの実行速度を大幅に改善させるプラグイン</title>
      <link>https://cake.nichiyoubi.land/posts/34-fixturize/</link>
      <pubDate>Sat, 22 Dec 2018 16:16:36 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/34-fixturize/</guid>
      <description>※1人AdventのDay-22です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
概要 friendsofcake/fixturizeは、CakePHPにおける単体テストの実行速度を大幅に改善させるプラグインです。
MySQL互換RDBMSで利用が可能で、導入は簡単です。
実際の利用方法と
イントロ CakePHPのTestSuiteでは、非常に簡単にDBと連携したフィクスチャデータを利用することができます。
予めPHPクラスとして記述しておいたスキーマやレコードの内容を、必要に応じて指定した通りに読み込む形です。
レコードの作成作業は、各テストケースの実行時に行われます。
このライフサイクルは直感的でクリーンさを保ちやすい一方で、懸念となるのは実行速度です。1つのテストケースごとに、毎回「テーブルの中身の破棄」「完全なデータのインサート」が行われるからです。
そうしたオーバーヘッドを削減するために作り出されたプラグインが、fixturizeです。
fixturizeの概要 FriendsOfCake/fixturize: CakePHP3: Improve performance of your fixture based tests on MySQL.
fixturizeは、既存の TestFixture クラスを当プラグインのクラスに置き換えることで実行されます。
通常のTestFixtureの処理をオーバーライドする形で、
 テストケース実行時(setUp)に 通常は「テーブルのトランケートを行う」ところで もし「今作成済みの対象テーブルの内容が、fixtureに記述された内容と差異がない」ことを確認できたら truncate/insert処理をスキップする  という機能を追加します。
そのために、「fixtureデータの作成・破棄・更新」に係るコストが省略されるわけです。
この結果、レポジトリにあるREADMEの内容を参照すると大変な時間短縮の成果を生み出しています。
導入 導入はとてもシンプルです。
READMEの内容をそのまま参照します。
 composerを利用してインストールする  composer require friendsofcake/fixturize  既存のfixtureの、継承元クラスを変更する   もちろん、extends CheckSumTestFixture をしても良いと思いますが、importを書き換えてaliasを当てる〜とした方が手間が少ないです   導入はこれだけで完了です。
実装詳細 それでは、どのように「無駄な更新はスキップする！」を実現しているのでしょうか。
具体的な実装内容について確認していきます。
ChecksumTestFixtureがオーバーライドしているメソッドは、 insert() truncate() drop() の3つのメソッドです。</description>
    </item>
    
    <item>
      <title>ORM/Database/Datasourceの棲み分け</title>
      <link>https://cake.nichiyoubi.land/posts/10-orm-database/</link>
      <pubDate>Fri, 21 Dec 2018 19:40:10 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/10-orm-database/</guid>
      <description>※1人AdventのDay-21です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
概要 CakePHP3のデータベース周りの処理を追っていくと、「ORM」「Database」「Datasource」という、似た名前のレイヤーが存在することに気づきます。
普段は特に意識することのないこれらの違いは、どこにあるのでしょうか。
気になったので調べてみました。
イントロ CakePHP3を2.xと比較すると、最も大きな革新の1つはデータベース周りの構造の改革である、ということは間違いないと思います。
それは、普段のアプリケーションを行っている上で直接的に目にするTale/Entity/Queryといったオブジェクトたちの登場から、感じることができます。そこから更に注意深くみてみると、フレームワークの内部ではさらなる複雑化が実施されていました。
これらの構造については、普段の開発では意識することはないかも知れません。しかしながら、内部構造についてイメージを掴むことで、フレームワーク自体の設計思想やポテンシャル、&amp;rdquo;らしさ&amp;rdquo;についての理解が深まるのかとも思います。
気になったので、自分なりに整理をしてみることにしました。
ORM層を起点に「複雑さ」を感じてみる まずは、最も馴染みが深いであろう \Cake\ORMです。
この中には、Table Entity Query などのクラスがあります。
 さて、これ自体は普段から目にしている通りであって特に重要ではないのですが、問題は「実は結構いろいろと継承している」というところにあります。
例えば、Tableクラスを見てみましょう。 何かを継承しているわけではないのですが、\Cake\Datasource\RepositoryInterfaceの実装であり、内部的には\Cake\DatabaseからTableSchema Typeというクラスを利用し、\Cake\DatasourceからはConnectionInterfaceとも関係していることが見て取れます。
同様に、EntityQueryについてもクラス図を置いてみます。
 Entity    Query     このように、ORM/Database/Datasourceは、それぞれが密接に関わり合っていることがわかります。
どのように違うのか？ 実は、これらの3層はそれぞれがcakephpのGitHubアカウントにてスタンドアロンパッケージとして切り出され、公開されています。
そこにあるdescriptionを見ることが、互いの位置づけを掴む上での端的な説明になりそうです。
 cakephp/orm: [READ-ONLY] A flexible, lightweight and powerful Object-Relational Mapper for PHP, implemented using the DataMapper pattern. This repo is a split of the main code that can be found in https://github.</description>
    </item>
    
    <item>
      <title>CakePHP 3.7.1がリリースされたので更新内容を確認</title>
      <link>https://cake.nichiyoubi.land/posts/33-cakephp-3_7_1/</link>
      <pubDate>Wed, 19 Dec 2018 23:25:17 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/33-cakephp-3_7_1/</guid>
      <description>※1人AdventのDay-19です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
概要 CakePHP3.7.1がリリースされたので、その内容をチェックしてみます。
今回は3.7.x系の初アップデートということもあり、コミュニティにおいて発見されたものを中心としたbugfixが多く見られました。
イントロ CakePHP3.7が、12月9日にリリースされました。
その際には、以下の記事で言及しています。
CakePHP 3.7の個人的な見どころ
それから9日後の12月18日に、3.7.1がリリースされています。
 bakery: CakePHP 3.7.1 Released — Bakery GitHub Release: Release CakePHP 3.7.1 released · cakephp/cakephp GitHub Issues: 3.7.1 Milestone  この記事では、今回のアップデートで反映された修正をみてみたいと思います。
Bugfixes このアップデートでは、新機能の実装は行われずにBugfixesのみとなっています。
cellがtemplateを発見できなかった場合に出力されるエラーメッセージを適切にセットできるように Fixed incorrect error messages when cells cannot find their template.  3.7 cell - exception by saeideng · Pull Request #12783 · cakephp/cakephp
「Cookieがセットされていない」を検査するアサーションの不具合を修正 Fixed a regression in assertCookieNotSet().  Fixed regression in assertCookieNotSet by jeremyharris · Pull Request #12794 · cakephp/cakephp</description>
    </item>
    
    <item>
      <title>Behaviorを使うか、Traitにするか</title>
      <link>https://cake.nichiyoubi.land/posts/32-behavior-vs-trait/</link>
      <pubDate>Sun, 16 Dec 2018 16:04:42 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/32-behavior-vs-trait/</guid>
      <description>※1人AdventのDay-16です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
概要 CakePHP3ではBehaviorを利用することで、Tableクラスにmixinすることができます。また、PHPにはTraitの仕組みがあり、これを利用することで継承を用いずにメソッドやプロパティの再利用を実現することができます。
現時点で考えている、個人的な「どう使い分けるか」というポイントをまとめてみます。
イントロ CakePHPには3.xより前のバージョンから、Modelレイヤーに「Behavior」という機構があります。複数のModel(Table)クラスで同様に利用されるような機能を、Modelを通じて透過的に利用できるようにしようというものです。これを利用することで、呼び出し側は、その機能がModelクラスに直接所属しているのかBehaviorから提供されているかを全く意識することなく利用ができます。
例えば、 TreeBehavior などはCakePHPにおいて過去から継続して提供されているユニークな例の1つでしょう。 $Model-&amp;gt;find(&#39;children&#39;, [&#39;for&#39; =&amp;gt; 100]) などとすれば、「アイテム100番に属する子アイテムを取得する」という操作が可能です。
一方で、PHP5.4からTrait機構が言語から提供されています。
CakePHP2.xはPHP5.3.0での利用を前提としているためにTraitの利用は選択肢に含まれませんが、CakePHP3.xにおいては状況が異なります。「Traitを利用して、Tableクラスに直接メソッドを植え付ける」ことが可能になりました。
単純なメソッド提供だけに絞れば同等の利用ができそうな両者は、どのように共存していけばよいのでしょうか？
個人的なシンプルな結論 個人的には、「Traitで済むものはTraitで良いのではないか」と考えるようにしています。その範疇外のものや、出来なくはないが考慮すべきことが増える場合などにはBehaviorを利用します。
PHPにおけるTraitの位置付け Traitが言語から提供されるようになってから、「どう使うか」というのは議論の的です。とりわけ、Abstract/Interfaceと交えて「デザインの仕方が大きく変わりそう」という関心を集めているように感じます。
必ずしもTrait(のみ)の話ではないですが、個人的な「Classの役割が狭まり、Traitの利用箇所は多岐に渡って拡大していくのではないか」という考え方は、こちらのエントリーにインスパイアされた面があります。
PHP 7 の無名クラスから考えるクラスの在り方 - Shin x Blog
今回は無名クラスの話ではないので、スコープが異なるのですが、それでも「Traitでやれること─とりわけ、具体実装についてはTraitを利用していく」という意味で合致しています。
Traitで済むこと 「メソッドの提供」のみであれば、Traitでもできそうです。また、visible/non-visibleなクラスメンバ・インスタンスメンバを利用する場合でも、traitは十分に活用できます。
例えばカスタムファインダメソッドの提供などは、Traitでも行けそうです。
「Queryインスタンスが渡されてきて」「呼び出し時に$optionを受け取ることができる」というインターフェイスにすれば問題なく動作します。その中に、formatResults()やwhere()/order()のデコレーションを実装することができるし、面倒くさいQueryExpressionを内部で組み立てて上げることも出来るわけです。
こう考えると、従来的なBehaviorの役割は、その多くをTraitに託すことも可能なのではないでしょうか？
Behaviorを使う場面①: ライフサイクルへの CakePHPにはModelの利用に関するライフサイクルが存在し、イベントベースで処理を割り込ませることが可能です。
コールバックのライフサイクル
これらを活用する場合、Bahaviorでの機能提供を行ったほうが無難かと考えています。
Bahaviorでは、各イベントの発火時にTableクラス自体とBehaviorが持つそれぞれの処理が考慮されるようにデザインされています。例えば、Behaviorに beforeFindメソッドをもたせた場合、Model.beforeFind にぶら下げて実行させる事は容易です。 他方で、Traitに定義された beforeFind() メソッドは、それを利用するTable自体の beforeFind() と見分けが付きません。そのため、「TableとBehaviorのbeforeFind()を明示的に双方とも呼び出す」ことが必要になります。これは、実装時にうっかりと忘れてしまいそうではないでしょうか・・?
そういう訳で、もし「ライフサイクルに則ってイベントを購読する」ことが重要な場合は、Behaviorを利用したほうがストレスなく開発を勧めていけるのではないかと思います。もちろん、具体的な実装をTraitに持たせつつ、Tabelの内部のメソッド(例えばinitialize()やbeforeMarshal())、implemetedEventsに登録されているメソッドの内部からTraitの処理を呼び出す」といった方法は可能です。
Behaviorを使う場面②: 設定値の管理 Behaviorの中での何らかの設定値を扱う場面もあります。その際に、 ConfigTraitを利用するなど、インスタンス内部に $_config というプロパティを作成することで管理するでしょうか。
もしTraitで同様のことを行おうとすると、利用側となるTableの持つプロパティと区別をできずに競合する可能性があります。
これを無難に回避するために、設定や状態管理を伴うある程度複雑な機能については、Behaviorとして「別クラス」を定義してしまうほうが良いのかなと感じます。
Behaviorを使う場面③: (静的)プロパティの利用・共有 設定値の管理の変形バージョンといえる話かもしれません。
ある機能を専任的に扱う存在としてのBehaviorを考える場合、「他のクラスに対しても影響をもたらす値の管理」を行いたい場合があります。
例えば「管理者モードを扱えるようにするBehavior」において「一時的に非管理者モードでのアクセスを行う」ような実装を考えていたとします1。この状態切り替えを、すべて「読み込み時に完了できる」もしくは「操作実行時に、都度参照できる」ようになれば、問題なくモードの切替が達成できると思います。
後者のアプローチを考える場合、Behaviorなら「自身の中に値を保持する」「それを都度参照するようにする」ことが可能です。各Tableからみて、「1箇所だけ見れば済む」ようになりました。他方で、Traitでは「自身の中に持つ」という状況を作り出すのが困難です。Traitの中にプロパティを生やすことはもちろん可能ですが、それは「各Tableに複製される」ようになります。すなわち、どれか1つを変更したところで、他Tableの手が届くところへの影響はあません。</description>
    </item>
    
    <item>
      <title>Entityの`$_accessible`について、もう1度。</title>
      <link>https://cake.nichiyoubi.land/posts/31-look-into-accesible/</link>
      <pubDate>Fri, 14 Dec 2018 06:44:56 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/31-look-into-accesible/</guid>
      <description>※1人AdventのDay-14です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
概要 CakePHP3では、データの誤操作を防ぐためEntityの持つプロパティへの代入可否を設定する $_accessible 機構が備わっています。
具体的な利用方法を確認していきたいと思います。
イントロ フレームワークを利用したアプリケーション開発の最大のメリットの1つが「簡単・少量の記述で、パワフルなシステムを構築できる」点にあると思います。
その一方で、「うっかりと変なことをやってしまう」リスクが高まる部分もあります。とりわけ、セキュリティやデータ操作の領域においての「うっかり」は取り返しのつかないダメージになりえます。
CakePHP3において、データの健全な扱いを支援するための機構の1つが Entity::$_accessibleによるプロパティの保護です。
これを設定することで、データを簡易に代入しつつ更新を許したくないプロパティについては渡された値を無視できるようになります。
利用例(Cookbookより) まずは、Cookbookにある例をひきながらその基本的な利用の方法についておさらいをしましょう。
エンティティー - 3.7
最も基本的な設定方法は、以下のとおりです。
namespace App\Model\Entity; use Cake\ORM\Entity; class Article extends Entity { protected $_accessible = [ &#39;title&#39; =&amp;gt; true, &#39;body&#39; =&amp;gt; true, &#39;*&#39; =&amp;gt; false, ]; }  Enittyのメンバーとして $_accessible を設け、その連想配列の中に「key =&amp;gt; 代入の可否」という形で値をもたせます。明示的に指定されていないプロパティはデフォルトではすべて false(代入不可)となり、「明示指定していないプロパティ(=「その他」のプロパティ)の挙動を変える」という場合には * を利用します。
$_accessible が適用される場面 $_accessible による代入保護が働く場面は、主に以下の3つです。
 Table::newEntity() によるEntityの作成、 Table::patchEntity() によるEntityの更新 newキーワードを利用したEntityの作成において、オプション(コンストラクタの第2引数となる連想配列)で &#39;guard&#39; =&amp;gt; true を指定した場合 Entity::set() で、第1引数が連想配列の場合  1・2のケースでも内部的にはset()メソッドを利用しており、結果的には3の挙動が適用されることになります。</description>
    </item>
    
    <item>
      <title>カスタムファインダーについておさらい</title>
      <link>https://cake.nichiyoubi.land/posts/30-custom-find/</link>
      <pubDate>Thu, 13 Dec 2018 19:09:01 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/30-custom-find/</guid>
      <description>※1人AdventのDay-13です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
概要 CakePHP3で導入された「カスタムファインダー」は、Queryの組み立てを抽象化・パッケージ化する手法です。
よく利用するconditonsの追加やfields、formatResultsなどの手順を一箇所にまとめ、更にメソッドチェーンによるQueryのビルドを可能にします。
イントロ CakePHP3のORM機能の1つに、Tableで提供されている「カスタムファインド」というものがあります。
これは、より「鮮明で簡潔なコーディングをする」ことを支援する強力な機能だと思っています。
とはいっても、自分自身もCakePHP3を触り始めた当初はその存在1を知らず、利用できていませんでした。今になって感じるのは、うまく付き合えばより「Cakeらしい」コードが書けそうだということです。
この記事では、その具体的な実装や内部処理の流れについて触れていきます。
簡単な利用例(Cookbookより) まずは、Cookbookにある内容を例にとって、簡単なサンプルに触れてみたいと思います。 データの取り出しと結果セット - 3.7
use Cake\ORM\Query; use Cake\ORM\Table; class ArticlesTable extends Table { public function findOwnedBy(Query $query, array $options) { $user = $options[&#39;user&#39;]; return $query-&amp;gt;where([&#39;author_id&#39; =&amp;gt; $user-&amp;gt;id]); } } // コントローラーやテーブルのメソッド内で $articles = TableRegistry::get(&#39;Articles&#39;); $query = $articles-&amp;gt;find(&#39;ownedBy&#39;, [&#39;user&#39; =&amp;gt; $userEntity]);  よくありそうな、「記事の筆者によって絞り込む」という処理です。
これはWHERE author_id = :user_id という条件付けによって達成されます。
カスタムファインダーを使う際には、2つの手順が必要です。
 findXxx という規則に従ってメソッド名をつける Table::find(&#39;Xxx&#39;) という形で呼び出す  とてもシンプルですが、これだけでOKです。</description>
    </item>
    
    <item>
      <title>CakePHP 3.7の個人的な見どころ</title>
      <link>https://cake.nichiyoubi.land/posts/28-cakephp-3_7/</link>
      <pubDate>Sun, 09 Dec 2018 22:34:12 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/28-cakephp-3_7/</guid>
      <description>※1人AdventのDay-9です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
晴れて、CakePHPの3.7がリリースされました。
CakePHP 3.7.0 Released — Bakery
ここしばらく、「4へのスムーズな移行をするために」を意識し続けてきたCakePHPコミュニティです。その様子は、別の場所に自分なりの観点でまとめてみています。
 今からちょっとだけ先の未来、CakePHP4の話 〜Upcoming CakePHP Roadmap &amp;amp; Releases〜 - コネヒト開発者ブログ CakePHP3.6.0のbeta1が出たのでおさらいしてみる - コネヒト開発者ブログ  そして、本来であれば「出さずに済ませたかった」とも言える3.7であり、これが3系のファイナルバージョンとなるはずです。
リリースノートと移行ガイドから、その内容を読み取ってみます。
主観により取捨選択しているので、詳細は原文を参照してください。
 CakePHP 3.7.0 Released — Bakery 3.7 Migration Guide - 3.7  CakePHP3.xの最終バージョン  This release is the last planned feature release for 3.x. Going forward the core team will be focusing on supporting 3.7 and completing 4.0.0.
 とされています。</description>
    </item>
    
    <item>
      <title>dereuromark/cakephp-dtoに触ってみる</title>
      <link>https://cake.nichiyoubi.land/posts/27-cakephp-dto/</link>
      <pubDate>Sat, 08 Dec 2018 18:12:32 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/27-cakephp-dto/</guid>
      <description>※1人AdventのDay-8です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
CakePHP開発者であるMark Sch.さんが、新しいプラグインを公開されていました。 [New]dereuromark/cakephp-dto CakePHP DTO Plugin https://t.co/vBFe8DJUPE
&amp;mdash; function(){exit;} (@call_user_func) 2018年12月8日 
名前の通り、CakePHPでDTOを扱うための実装のようです。
cf) Data Transfer Object - Wikipedia
おもしろそうなので、早速触ってみました。
ざっくりいうと何？  決められたプロパティを持つmutable/immutableなオブジェクトを扱いやすくするためのもの 決められたプロパティ = 型は、設定ファイルに記述していく それらの設定を、実クラス生成コマンドによって作成する 実際のクラスを生成するからIDE上での保管や静的解析との相性が良い  CakeDTOに触ってみる setup まずは、インストールです
composer require dereuromark/cakephp-dto:dev-master  Pluginを有効化します。1
bin/cake plugin load CakeDto -b  はじめてのDTO作成 ファイル初期生成用のコマンドが用意されています。
bin/cake dto init  これを実行すると、config/dto.xmlに以下のようなファイルが設置されます
&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt; &amp;lt;dtos xmlns=&amp;quot;cakephp-dto&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;cakephp-dto https://github.com/dereuromark/cakephp-dto&amp;quot;&amp;gt; &amp;lt;/dtos&amp;gt;  ・・・と言っておいて何ですが、個人的にYAMLでいきたいのでYAMLに書き換えます。 こちらのExampleを参考にしましょう。 /examples/basic.dto.yml</description>
    </item>
    
    <item>
      <title>findOrCreate()時にvalidationを行う</title>
      <link>https://cake.nichiyoubi.land/posts/24-find-or-create-validation/</link>
      <pubDate>Sun, 02 Dec 2018 18:12:32 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/24-find-or-create-validation/</guid>
      <description>※1人AdventのDay-2です
1人advent(CakePHP中心、PHP開発よもやま) Advent Calendar 2018 - Adventar
先日、Modelを書いているときにfindOrCreate()の挙動でハマった部分があったので調べてみました。 バリデーションが期待通りに動かなかったので、その対応を書いています。
findOrCreateメソッドについて CakePHP3のTableClassに、 findOrCreate() というメソッドがあります。
code: https://github.com/cakephp/cakephp/blob/3.6.13/src/ORM/Table.php#L1686
これは、「第1引数で渡されたデータを検索する。DB上に存在しなければ、新規にEntityを作成・保存し、それを返却する」というものです。知っていると、多くの場面で使いたくなります。
$data = [&#39;name&#39; =&amp;gt; &#39;new太郎&#39;]; $entity = $this-&amp;gt;Table-&amp;gt;findOrCreate($data);  この結果として、(DB上にすでにレコードがあるか無いかにかかわらず) {name: new太郎} のEntityインスタンスが取得される、というわけです。なお、 すでに persistent 済みであるため、$entity-&amp;gt;isNew() はfalseとなります。
実装内容について詳しく もう少し、内部処理について詳しく見てみましょう。
// \Cake\ORM\Table public function findOrCreate($search, callable $callback = null, $options = []) { $options = new ArrayObject($options + [ &#39;atomic&#39; =&amp;gt; true, &#39;defaults&#39; =&amp;gt; true, ]); $entity = $this-&amp;gt;_executeTransaction(function () use ($search, $callback, $options) { return $this-&amp;gt;_processFindOrCreate($search, $callback, $options-&amp;gt;getArrayCopy()); }, $options[&#39;atomic&#39;]); if ($entity &amp;amp;&amp;amp; $this-&amp;gt;_transactionCommitted($options[&#39;atomic&#39;], true)) { $this-&amp;gt;dispatchEvent(&#39;Model.</description>
    </item>
    
    <item>
      <title>`Query` を愛用する。(もしくは `-&gt;all()` を避ける)</title>
      <link>https://cake.nichiyoubi.land/posts/1-use-query/</link>
      <pubDate>Tue, 27 Mar 2018 13:52:39 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/1-use-query/</guid>
      <description>Cake2では、Modelからの返却値がすべて配列でした。
そのため、私はCake3を利用し始めた当初、「データベースからの取得した内容」は「値の集合」に変換して処理するぞ！みたいな意識が働きがちでした。
例えばこんな様子です
$books = $this-&amp;gt;Books-&amp;gt;find()-&amp;gt;all(); $this-&amp;gt;set(compact(&#39;books&#39;));  もっと酷い時は、ResultSetの使い方に難儀してhydrationをいじって、そのまま配列にして処理を・・・という書き方をしたりもしました。
ref: Class Cake\ORM\Query | CakePHP 3.4
しかし、QueryはIteratorAggregateを備えているので、「それをそのままループさせる」ことでレコードを処理することが可能です
// in controller $books = $this-&amp;gt;Books-&amp;gt;find(); $this-&amp;gt;set(compact(&#39;books&#39;)); // in template &amp;lt;?php foreach ($books as $book): ?&amp;gt; &amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;&amp;lt;?= h($book-&amp;gt;title) ?&amp;gt;&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;?php endforeach; ?&amp;gt;}  個人的には「単純にレコードを取り出したいだけ」の時は(all()などを使って)ResultSet化しないでQueryオブジェクトのままやり取りすることが多いです。
 Queryのままにしておく = 結果を確定させないままの状態を維持しておくことで利用できる機能があるため  orderやwhereの追加、subqueryの利用など  後にロジックの改修があったときに変更をしやすい  1と同じ理由です  明示的にall()を使っている箇所について、必ず「ResultSetが欲しい」「DBにクエリを実行させたい」と言ったような意図をコード上で表現できるようになる 単純にコードが減る  1,2は昨日の話です。3,4は表現力の話です。
これらに鑑みて、「デメリットはあまり無さそうでちょっとメリットがあるな」というのが、現時点での私の所見です。</description>
    </item>
    
    <item>
      <title>コレクションを任意の順番で並び替える</title>
      <link>https://cake.nichiyoubi.land/posts/16-collection/</link>
      <pubDate>Sun, 25 Mar 2018 20:35:59 +0900</pubDate>
      
      <guid>https://cake.nichiyoubi.land/posts/16-collection/</guid>
      <description>コレクションを任意の順番で並び替える PHPを使っていると、「任意に順番を並び替えたキーに沿って、連想配列を並び替えたい」ということが意外と面倒くさかったりする。
MySQLでいう ORDER BY FIELD(field, idx1, idx2, idx3) みたいなやつ。
Collectionクラスを用いると簡単にできそうだな〜と思ったのでメモ。
$order = [2, 1, 3]; $data = collection([ [&#39;id&#39; =&amp;gt; 1, &#39;name&#39; =&amp;gt; &#39;John&#39;], [&#39;id&#39; =&amp;gt; 2, &#39;name&#39; =&amp;gt; &#39;Alice&#39;], [&#39;id&#39; =&amp;gt; 3, &#39;name&#39; =&amp;gt; &#39;Yui&#39;], ]); $orderMap = array_flip($order); $data = $data-&amp;gt;sortBy( function ($datum) use ($orderMap) { return $orderMap[$datum-&amp;gt;id]; }, SORT_ASC ) -&amp;gt;compile(false);  何をしているかというと、
 array_flipでもとの並び順を覚えさせて 対応順にarrayに位置を教えてあげる  というだけのもの。
Collectionクラスは、以前にQiitaにも書いた。
とても便利で強力なUtilityなので、使いこなしたい。
[CakePHP3]現場で使えるCollectionクラスの15選 - Qiita</description>
    </item>
    
  </channel>
</rss>